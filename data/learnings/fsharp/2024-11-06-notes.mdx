---
title: Notes on F# | 2024-11-06
category: fsharp
courseTitle: Learning F# with SAFE stack
courseLink: https://safe-stack.github.io/
status: In Progress
publishedAt: 2024-11-06
description: Watching video x, y, and z
seoDescription: Watching video x, y, and z
author: { name: "joe307bad" }
subTitle: Immutability by default + strong type system + .NET = F#
tags:
  - F#
---

Building and maintaining software can be a difficult endeavor as the software's complexity and feature set grow over time. Squashing bugs, layering on new functionality, and delivering something people enjoy is not an easy task. Building reliable, predictable software is easier when the toolset ensures a program's correctness before deploying to production. In my experience, functional languages like Haskell and Elm produce the most reliable software but the sparse ecosystem of third-party tech hinders productivity. After learning [F#](https://fsharp.org/) for a few weeks, it's clear that F# is so powerful because it is functional-first (and thus will produce more reliable software) and there is an east escape hatch to C# or TypeScript (which preserves the massive ecosystem of both of these very popular programming languages). F# strikes an excellent balance between ensuring a program's correctness before reaching production and preserving an ecosystem of (non-functional-first) third-party dependencies. Here are some notes on my first few weeks with F#.
<br />
First, let's cover why I think F# is a superior programming language. F# has an advanced type system that provides maximum type inference and helpful error messages about potential failure points in your code. This type of compiler-first programming is the best way to build reliable software. For functional languages with a strong type system (like F#), the compiler provides high confidence that the program will function without any runtime exceptions. While eliminating runtime exceptions (like Elm) is almost impossible in the more loosely typed universe of C#, F# still makes assurances against classes of errors (null exceptions) while still maintaining complete interoperability with .NET. 
<br />
Next, I want to talk about functional programming on the front end. You can write code in F# and compile it to Python, JavaScript or Dart using a compiler called [Fable](https://fable.io). The most mature target for Fable is JavaScript. I spent a few weeks building a single-page application (SPA) with Fable and a few other complimentary libraries and it was fantastic. Together with a state management library called [Elmish](https://github.com/elmish/elmish), writing an entire front-end application in idiomatic F# was a thrilling experience. The clear advantages are the runtime exception elimination guarantees of Elm (using Elmish) along with the ecosystem of NPM (for core dependencies like data-intensive tables or multi-select dialogs).
<br />
Finally, I wanted to touch on the next steps. As I continue to work on a passion project using SAFE stack and F#, I'll be focused on four problem areas: 1) domain modeling in F# using [Saturn](https://saturnframework.org/) as my project becomes more complex and needs more backend features, 2) coordinating a front-end primarily written in F# but with dependencies on tables and UI components written in TypeScript, 3) integrating a separate system into my main rest API using some queue implementation (like Kafka) and 4) deploying and provisioning all this on my local minikube cluster.
<br />
Happy coding!